/* ----------------------------------------------
 * Ethernet Traffic Generator
 * Opsero Electronic Design Inc. 2017
 * ----------------------------------------------
 *
 * Description:
 * ------------
 * This IP generates Ethernet frames and checks received Ethernet frames for bit
 * errors. It is designed to be interfaced with the AXI Ethernet Subsystem block.
 * The frames contain random data generated by an LFSR for simple verification at the
 * receiver. The LFSR is reset for each frame, thus the transmitted frame is always
 * the same and can be easily verified by the receiver.
 *
 * The frame generator (TXD handler) provides the FCS (checksum) to the MAC. Normally
 * we wouldn't provide the FCS to the MAC because it can calculate it automatically,
 * but in our case, we need to provide it so that we can generate forced errors in
 * the frame which will cause the FCS to be incorrect for the frame. Thus the
 * receiver MAC will reject it, and we can count a rejected frame.
 *
 * The frame receiver (RXD handler) reads the incoming Ethernet frames and compares
 * them with the known transmitted frame. Any errors found are pushed into a stream
 * which is read by the error handler and added to the bit error counter. The bit
 * error counter is written to a software register which can be read by the processor.
 * Note that most bit errors will be detected by the receiving MAC and dropped, due
 * to the incorrect FCS. We check all frames that get through the MAC in order to
 * catch any bit errors that slip through undetected by the FCS calculation.
 *
 * Limitations:
 * ------------
 * This design does not currently contain an FCS calculator, so instead it contains
 * one fixed FCS value, which corresponds to a pkt_len of 374 words.
 * The FCS value is based on MAC dst and src addresses of
 * FF FF FF FF 1E 00 and FF FF A4 A5 27 37 respectively. So although the design
 * allows for configuration of MAC addresses and packet length, it will only
 * function using the values mentioned above. An FCS calculator will be a future
 * addition to this example design.
 *
 */
#include <stdio.h>
#include <hls_stream.h>
#include <ap_int.h>

using namespace hls;

struct axiWord {
  ap_uint<32> data;
  ap_uint<4> keep;
  ap_uint<1> last;
};

/* ----------------------------------------------
 * Ethertype calculator
 * ----------------------------------------------
 * Generates the Ethertype word based on the packet length.
 *
 */
ap_uint<32> calc_ethertype(ap_uint<32> pkt_len) {
	ap_uint<16> pkt_len_bytes;

	// Convert the packet length in words, to packet length in bytes
	pkt_len_bytes = (pkt_len * 4) + 2;
	// Then switch byte order to form the Ethertype
	return((pkt_len_bytes.range(7,0),pkt_len_bytes.range(15,8)));
}

/* ----------------------------------------------
 * LFSR Random number generator
 * ----------------------------------------------
 * Generates random data for the transmitted Ethernet frames.
 *
 */
ap_uint<32> lfsr_next(ap_uint<32> *lfsr) {
	if((*lfsr)[31] == 1){
		*lfsr = (((*lfsr) ^ 0x00000062) << 1) | 1;
	}
	else{
		*lfsr = ((*lfsr) << 1);
	}

	return(*lfsr);
}

/* ----------------------------------------------
 * Force error handler
 * ----------------------------------------------
 * Monitors the force_error software register and triggers a bit error
 * when low-to-high transition is detected. Bit error is triggered by
 * writing to the force_error_trig stream.
 *
 */
void force_error_handler(ap_uint<1> *force_error,stream<ap_uint<1> >& force_error_trig) {
#pragma HLS pipeline II=1 enable_flush

	static ap_uint<1> sig_r = 0;

	if((sig_r != *force_error) && (*force_error == 1)){
		force_error_trig.write(1);
	}
	sig_r = *force_error;
}




/* ----------------------------------------------
 * TXD Transmit handler
 * ----------------------------------------------
 * Transmits Ethernet frames to the AXI Ethernet Subsystem.
 * The frames are composed as follows:
 *  - 3 words for destination and source MAC addresses
 *  - 1 word for Ethertype and padding
 *  - n words for the payload where n=pkt_len
 *  - 1 word for FCS (checksum)
 *
 * The AXIS interface is 32 bits (one word).
 * The AXIS keep outputs are always 1, ie. all bytes are used.
 * The payload is filled with random data generated from an
 * LFSR.
 *
 * Limitations:
 * ------------
 * This design does not currently contain an FCS
 * calculator, so instead it contains 2 fixed FCS values, which
 * correspond to a pkt_len of 16 words and 374 words respectively.
 * The FCS values are based on MAC dst and src addresses of
 * FF FF FF FF 1E 00 and FF FF A4 A5 27 37, so although the design
 * allows for configuration of MAC addresses and packet length, it
 * will only function using the values mentioned above. An FCS
 * calculator will be a future addition to this example design.
 */
void txd_handler(stream<axiWord>& txd,
		stream<axiWord>& txc,
		stream<ap_uint<1> >& force_error_trig,
		ap_uint<32> *dst_mac_lo,
		ap_uint<32> *dst_mac_hi,
		ap_uint<32> *src_mac_lo,
		ap_uint<32> *src_mac_hi,
		ap_uint<32> *pkt_len){
#pragma HLS pipeline II=1 enable_flush

	  static enum tState {TXD_INIT = 0, TXC_IDLE,
		  TXC_CTRLFRAME_0,TXC_CTRLFRAME_1,TXD_MAC_0, TXD_MAC_1, TXD_MAC_2,
		  TXD_ETHERTYPE,TXD_PAYLOAD,TXD_FCS} txdState;
	  static ap_uint<32> lfsr = 0xFFFFFFFF;
#pragma HLS reset variable=lfsr
	  static ap_uint<32> i = 0;
#pragma HLS reset variable=i
	  static ap_uint<32> j = 0;
#pragma HLS reset variable=j
	  static ap_uint<32> fcs_r = 0x58309809;
#pragma HLS reset variable=fcs_r
	  static ap_uint<1> force_err = 0;
#pragma HLS reset variable=force_err
	  static ap_uint<32> pkt_len_r = 0;
#pragma HLS reset variable=pkt_len_r
	  static ap_uint<32> ethertype_r = 0;
#pragma HLS reset variable=ethertype_r

	  static axiWord txcWord = {0, 0xF, 0};
	  static axiWord txdWord = {0, 0xF, 0};

	  switch(txdState) {
	  case TXD_INIT:
		  // Wait for a valid packet length from the software
		  if((*pkt_len > 0) && (*pkt_len <= 374)){
			  pkt_len_r = *pkt_len;
			  // Calculate FCS
			  if(pkt_len_r == 374){
				  fcs_r = 0x1942A4BF;
			  }
			  // Calculate ethertype
			  ethertype_r = calc_ethertype(pkt_len_r);
			  txdState = TXC_IDLE;
		  }
		  break;

	  case TXC_IDLE:
		  // Start sending the control frame
		  txcWord.last = 0;
		  txcWord.data = 0xA0000000;
		  txc.write(txcWord);
		  i = 0;
		  txdState = TXC_CTRLFRAME_0;
		  break;

		case TXC_CTRLFRAME_0:
			// Send the rest of the control frame
			txcWord.data = 0;
			txc.write(txcWord);
			if(i == 3)
				txdState = TXC_CTRLFRAME_1;
			i++;
			break;
		case TXC_CTRLFRAME_1:
			// Send the last word
			txcWord.data = 0;
			txcWord.last = 1;
			txc.write(txcWord);
			// Reset the LFSR
			lfsr = 0xFFFFFDA3;
			// Reset the AXIS last signal
			txdWord.last = 0;
			txdState = TXD_MAC_0;
			break;
	  case TXD_MAC_0:
			// Output the MAC address word 0
			txdWord.data(7,0) = (*dst_mac_hi)(15,8);
			txdWord.data(15,8) = (*dst_mac_hi)(7,0);
			txdWord.data(23,16) = (*dst_mac_lo)(31,24);
			txdWord.data(31,24) = (*dst_mac_lo)(23,16);
		  txd.write(txdWord);
		  txdState = TXD_MAC_1;
		  break;

	  case TXD_MAC_1:
		  // Output the MAC address word 1
		  txdWord.data(7,0) = (*dst_mac_lo)(15,8);
		  txdWord.data(15,8) = (*dst_mac_lo)(7,0);
		  txdWord.data(23,16) = (*src_mac_hi)(15,8);
		  txdWord.data(31,24) = (*src_mac_hi)(7,0);
		  txd.write(txdWord);
		  txdState = TXD_MAC_2;
		  break;

	  case TXD_MAC_2:
		  // Output the MAC address word 2
		  txdWord.data(7,0) = (*src_mac_lo)(31,24);
		  txdWord.data(15,8) = (*src_mac_lo)(23,16);
		  txdWord.data(23,16) = (*src_mac_lo)(15,8);
		  txdWord.data(31,24) = (*src_mac_lo)(7,0);
		  txd.write(txdWord);
		  txdState = TXD_ETHERTYPE;
		  break;

	  case TXD_ETHERTYPE:
		  // Output the EtherType word + padding
		  txdWord.data = ethertype_r;
		  txd.write(txdWord);
		  txdState = TXD_PAYLOAD;
		  j = 0;
		  break;

	  case TXD_PAYLOAD:
		  // Output the payload (random data)
		  // Calculate new LFSR value, replace old one
		  txdWord.data = lfsr_next(&lfsr);
		  txd.write(txdWord);
		  if(j == (pkt_len_r - 1))
			  txdState = TXD_FCS;
		  j++;
		  break;

	  case TXD_FCS:
		  // Output the FCS and generate error if requested
		  if(!force_error_trig.empty()){
			  force_error_trig.read(force_err);
			  txdWord.data = fcs_r xor 0x10000000;
		  } else {
			  txdWord.data = fcs_r;
		  }
		  txdWord.last = 1;
		  txd.write(txdWord);
		  // Start another frame
		  txdState = TXD_INIT;
		  break;

	  }
}


/* ----------------------------------------------
 * RXS Receive handler
 * ----------------------------------------------
 * Reads incoming frames on RXS and does nothing with the data.
 *
 */
void rxs_handler(stream<axiWord>& rxs){
#pragma HLS pipeline II=1 enable_flush
	  static enum rsState {R_INIT = 0, R_IDLE, R_FRAME} rxsState;

	  axiWord rxWord = {0, 0xF, 0};

	  switch(rxsState) {
	  case R_INIT:
		  rxsState = R_IDLE;
		  break;
	  case R_IDLE:
		  rxsState = R_FRAME;
		  break;
	    case R_FRAME:
			// Read the RXS frame
	    	if(!rxs.empty()){
	    		rxs.read(rxWord);
	    		if(rxWord.last == 1){
	    			rxsState = R_IDLE;
	    		}
	    	}
	    	break;
	  }
}


/* ----------------------------------------------
 * Error count function
 * ----------------------------------------------
 * Compares two words and returns the number of bit differences.
 *
 */
ap_uint<32> error_count(ap_uint<32> data, ap_uint<32> expected){
#pragma HLS pipeline II=1 enable_flush
	ap_uint<32> error_mask = 0;
	ap_uint<32> error_count = 0;
	ap_uint<32> i = 0;

	error_mask = data xor expected;

	for(i = 0; i<32; i++){
		error_count += error_mask[i];
	}

	return(error_count);
}


/* ----------------------------------------------
 * RXD Receive handler
 * ----------------------------------------------
 * Reads incoming frames on RXD and checks for bit errors.
 * We are able to check every word for errors because the TXD
 * handler always sends the same frame and we know what it is.
 * Most bit errors will get caught by the MAC FCS resulting in
 * dropped frames, but we check the received packets anyway
 * just to cover the possibility that they slip through.
 *
 */
void rxd_handler(stream<axiWord>& rxd,stream<ap_uint<32> >& err_strm,
		ap_uint<32> *dst_mac_lo,
				ap_uint<32> *dst_mac_hi,
				ap_uint<32> *src_mac_lo,
				ap_uint<32> *src_mac_hi,
				ap_uint<32> *pkt_len){
#pragma HLS pipeline II=1 enable_flush
	  static enum rdState {R_INIT = 0, R_MAC_0, R_MAC_1, R_MAC_2,
		  R_ETHERTYPE, R_PAYLOAD, R_FCS, R_TRAILER} rxdState;

	  axiWord rxWord = {0, 0xF, 0};
	  static ap_uint<32> lfsr = 0xFFFFFFFF;
#pragma HLS reset variable=lfsr
	  static ap_uint<32> i = 0;
#pragma HLS reset variable=i
	  static ap_uint<32> fcs_r = 0x58309809;
#pragma HLS reset variable=fcs_r
	  static ap_uint<32> pkt_len_r = 16;
#pragma HLS reset variable=pkt_len_r
	  static ap_uint<32> ethertype_r = 0;
#pragma HLS reset variable=ethertype_r

	  switch(rxdState) {
	  case R_INIT:
		  // Wait for a valid packet length from the software
		  if((*pkt_len > 0) && (*pkt_len <= 374)){
			  pkt_len_r = *pkt_len;
				// Calculate FCS
				if(pkt_len_r == 374){
					fcs_r = 0x1942A4BF;
				}
				// Calculate ethertype
				ethertype_r = calc_ethertype(pkt_len_r);
				rxdState = R_MAC_0;
		  }
		  break;
	  case R_MAC_0:
		  // Wait for MAC0 word
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  err_strm.write(error_count(rxWord.data,((*dst_mac_lo)(23,16),(*dst_mac_lo)(31,24),(*dst_mac_hi)(7,0),(*dst_mac_hi)(15,8))));
			  if(rxWord.last == 1){
				  rxdState = R_MAC_0;
			  } else {
				  // Reset the LFSR
				  lfsr = 0xFFFFFDA3;
				  rxdState = R_MAC_1;
			  }
		  }
		  break;
	  case R_MAC_1:
		  // Wait for MAC1 word
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  err_strm.write(error_count(rxWord.data,((*src_mac_hi)(7,0),(*src_mac_hi)(15,8),(*dst_mac_lo)(7,0),(*dst_mac_lo)(15,8))));
			  if(rxWord.last == 1)
				  rxdState = R_MAC_0;
			  else
				  rxdState = R_MAC_2;
		  }
		  break;
	  case R_MAC_2:
		  // Wait for MAC2 word
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  err_strm.write(error_count(rxWord.data,((*src_mac_lo)(7,0),(*src_mac_lo)(15,8),(*src_mac_lo)(23,16),(*src_mac_lo)(31,24))));
			  if(rxWord.last == 1)
				  rxdState = R_MAC_0;
			  else
				  rxdState = R_ETHERTYPE;
		  }
		  break;
	  case R_ETHERTYPE:
		  // Wait for Ethertype word
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  err_strm.write(error_count(rxWord.data,ethertype_r));
			  if(rxWord.last == 1)
				  rxdState = R_MAC_0;
			  else {
				  // Initialize the packet length counter
				  i = 0;
				  rxdState = R_PAYLOAD;
			  }
		  }
		  break;
	  case R_PAYLOAD:
		  // Read the payload and compare with LFSR
			if(!rxd.empty()){
				rxd.read(rxWord);
				err_strm.write(error_count(rxWord.data,lfsr_next(&lfsr)));
				if(rxWord.last == 1)
					rxdState = R_MAC_0;
				else if(i == (pkt_len_r - 1))
					rxdState = R_FCS;
				i++;
			}
		  break;
	  case R_FCS:
		  // Wait for FCS (should be the last word in the frame)
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  err_strm.write(error_count(rxWord.data,fcs_r));
			  if(rxWord.last == 1)
				  rxdState = R_MAC_0;
			  else
				  rxdState = R_TRAILER;
		  }
		  break;
	  case R_TRAILER:
		  // Trailer state should never happen.
		  // Wait until the end of the frame.
		  // Probably should flag this occurrence to a software register.
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  if(rxWord.last == 1)
				  rxdState = R_INIT;
		  }
		  break;

	  }
}


/* ----------------------------------------------
 * Error counter
 * ----------------------------------------------
 * Receives error counts from the RXD handler, keeps the sum and writes
 * that value to the software register.
 *
 */
void error_counter(stream<ap_uint<32> >& err_strm,ap_uint<32> *err_count) {
#pragma HLS pipeline II=1 enable_flush
	static ap_uint<32> errors = 0;
#pragma HLS reset variable=errors
	ap_uint<32> count;

	if(!err_strm.empty()){
		err_strm.read(count);
		errors = errors + count;
	}
	*err_count = errors;
}



// Top level function
void eth_traffic_gen(stream<axiWord>& m_axis_txc,stream<axiWord>& m_axis_txd,
		stream<axiWord>& s_axis_rxs,stream<axiWord>& s_axis_rxd,
		ap_uint<1> *force_error,
		ap_uint<32> *dst_mac_lo,
		ap_uint<32> *dst_mac_hi,
		ap_uint<32> *src_mac_lo,
		ap_uint<32> *src_mac_hi,
		ap_uint<32> *pkt_len,
		ap_uint<32> *err_count) {
#pragma HLS INTERFACE axis port=m_axis_txc
#pragma HLS INTERFACE axis port=m_axis_txd
#pragma HLS INTERFACE axis port=s_axis_rxs
#pragma HLS INTERFACE axis port=s_axis_rxd
#pragma HLS INTERFACE ap_ctrl_none port=return
#pragma HLS INTERFACE s_axilite port=force_error bundle=p0
#pragma HLS INTERFACE s_axilite port=dst_mac_lo bundle=p0
#pragma HLS INTERFACE s_axilite port=dst_mac_hi bundle=p0
#pragma HLS INTERFACE s_axilite port=src_mac_lo bundle=p0
#pragma HLS INTERFACE s_axilite port=src_mac_hi bundle=p0
#pragma HLS INTERFACE s_axilite port=pkt_len bundle=p0
#pragma HLS INTERFACE s_axilite port=err_count bundle=p0
#pragma HLS dataflow

	// Force error trigger stream
	static stream<ap_uint<1> > force_error_trig;
#pragma HLS STREAM variable=force_error_trig depth=4 dim=1

	// Stream for synchronization of TXC and TXD handlers
	static stream<ap_uint<1> > txc_trig;
#pragma HLS STREAM variable=txc_trig depth=4 dim=1

	// Stream for error counting
	static stream<ap_uint<32> > err_strm;
#pragma HLS STREAM variable=err_strm depth=128 dim=1

	// Waits for force error register toggle and triggers error
	force_error_handler(force_error,force_error_trig);

	// Run the transmit and receive handlers
	txd_handler(m_axis_txd,m_axis_txc,force_error_trig,dst_mac_lo,dst_mac_hi,src_mac_lo,src_mac_hi,pkt_len);
	rxs_handler(s_axis_rxs);
	rxd_handler(s_axis_rxd,err_strm,dst_mac_lo,dst_mac_hi,src_mac_lo,src_mac_hi,pkt_len);

	// Error counter
	error_counter(err_strm,err_count);
}
